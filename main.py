import csv
import logging
import os
import sys
import re
from typing import Dict, Any, Optional
from collections import defaultdict, Counter
from dotenv import load_dotenv
import feedparser
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    ContextTypes,
    filters,
)

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –º–∞—Å–∫–∏—Ä–æ–≤–∫–∏ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –≤ –ª–æ–≥–∞—Ö
def mask_sensitive_data(message):
    if not isinstance(message, str):
        return message
    # –ú–∞—Å–∫–∏—Ä—É–µ–º BOT_TOKEN
    message = re.sub(r'(BOT_TOKEN[\s=:]+)([^\s]+)', r'\1***', message, flags=re.IGNORECASE)
    return message

# –ö–∞—Å—Ç–æ–º–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç—Ç–µ—Ä –ª–æ–≥–æ–≤ —Å –º–∞—Å–∫–∏—Ä–æ–≤–∫–æ–π
class SafeLogFormatter(logging.Formatter):
    def format(self, record):
        original = super().format(record)
        return mask_sensitive_data(original)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
console_handler = logging.StreamHandler(sys.stdout)
file_handler = logging.FileHandler('succ_bot.log')
formatter = SafeLogFormatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
console_handler.setFormatter(formatter)
file_handler.setFormatter(formatter)
logger.addHandler(console_handler)
logger.addHandler(file_handler)
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("telegram").setLevel(logging.WARNING)


class UserSession:
    __slots__ = ['branch', 'current_q', 'advices', 'confirmations', 'history', 'portraits', 'seen_subscription_prompt']
    def __init__(self):
        self.branch: Optional[int] = None
        self.current_q: Optional[int] = None
        self.advices: list = []
        self.confirmations: list = []
        self.history: list = []
        self.portraits: list = []
        self.seen_subscription_prompt: bool = False  # –ß—Ç–æ–±—ã –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø–æ–¥–ø–∏—Å–∫—É –¥–≤–∞–∂–¥—ã

    def start_branch(self, branch: int):
        self.branch = branch
        self.current_q = 1
        self.advices.clear()
        self.confirmations.clear()
        self.history = [1]
        self.portraits.clear()
        self.seen_subscription_prompt = False

    @property
    def portrait(self) -> str:
        if self.portraits:
            return Counter(self.portraits).most_common(1)[0][0]
        return "—É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π —Ä–∞–±–æ—Ç–Ω–∏–∫"

    def add_advice(self, advice: str):
        if advice and advice.strip():
            self.advices.append(advice.strip())

    def add_confirmation(self, confirmation: str):
        if confirmation and confirmation.strip():
            self.confirmations.append(confirmation.strip())

    def add_portrait(self, portrait: str):
        if portrait and portrait.strip():
            self.portraits.append(portrait.strip())

    def get_current_question(self, questions: dict) -> Optional[dict]:
        if self.branch is None or self.current_q is None:
            return None
        return questions.get(self.branch, {}).get(self.current_q)

    def move_to_next(self, next_q: int):
        if next_q is not None:
            self.current_q = next_q
            self.history.append(next_q)

    def go_back(self) -> bool:
        if len(self.history) > 1:
            self.history.pop()
            self.current_q = self.history[-1]
            return True
        return False


class FinanceBot:
    def __init__(self):
        self.images_dir = "images"
        if not os.path.exists(self.images_dir):
            os.makedirs(self.images_dir)
        self.user_sessions: Dict[int, UserSession] = {}
        self.questions = self.load_questions()
        self.texts = self.load_texts()
        self.community_link = os.getenv("COMMUNITY_LINK", "https://t.me/+25yK94v9nCoyNzFi")
        self.rss_feed_url = "https://fetchrss.com/feed/aI7uY390SFnyaI7uRt1OAptT.rss"

    def _clean_title(self, title: str) -> str:
        title = ' '.join(title.split())
        match = re.match(r'^([^.]*)\.', title)
        if match:
            cleaned = match.group(1).strip()
            if cleaned:
                return cleaned
        words = title.split()
        if len(words) > 6:
            return ' '.join(words[:6]) + '...'
        return title

    async def get_channel_updates(self) -> str:
        """–ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 5 –ø–æ—Å—Ç–æ–≤ –∏–∑ RSS —Ñ–∏–¥–∞ –∫–∞–Ω–∞–ª–∞"""
        if not self.rss_feed_url:
            logger.warning("RSS_FEED_URL –Ω–µ —É–∫–∞–∑–∞–Ω –≤ .env")
            return "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è."
        try:
            feed = feedparser.parse(self.rss_feed_url)
            if feed.bozo and not feed.entries:
                logger.warning("RSS –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω: %s", feed.bozo_exception)
                return "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤."
            seen = set()
            updates = []
            for i, entry in enumerate(feed.entries[:5]):
                clean_title = self._clean_title(entry.title)
                link = entry.link
                if link in seen:
                    continue
                updates.append(f"{i+1}. <a href='{link}'>{clean_title}</a>")
                seen.add(link)
            return "\n".join(updates) if updates else "–ù–µ—Ç –Ω–æ–≤—ã—Ö –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤."
        except Exception as e:
            logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ RSS: %s", mask_sensitive_data(str(e)))
            return "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è."

    def load_texts(self) -> Dict[str, str]:
        texts = {}
        try:
            csv_path = os.path.join(os.path.dirname(__file__), "texts.csv")
            if not os.path.exists(csv_path):
                logger.error("–§–∞–π–ª texts.csv –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ –ø—É—Ç–∏: %s", csv_path)
                return texts
            with open(csv_path, mode='r', encoding='utf-8-sig') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    if not row.get("key") or not row.get("text"):
                        continue
                    texts[row["key"]] = row["text"]
        except Exception as e:
            logger.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ texts.csv: %s", mask_sensitive_data(str(e)))
        return texts

    def load_questions(self) -> Dict[int, Dict[int, dict]]:
        questions = defaultdict(dict)
        csv_path = os.path.join(os.path.dirname(__file__), "questions_succ.csv")
        if not os.path.exists(csv_path):
            logger.error("–§–∞–π–ª –≤–æ–ø—Ä–æ—Å–æ–≤ %s –Ω–µ –Ω–∞–π–¥–µ–Ω", csv_path)
            return questions
        try:
            with open(csv_path, mode='r', encoding='utf-8-sig') as file:
                reader = csv.DictReader(file)
                for row in reader:
                    try:
                        if not row.get("–í–µ—Ç–∫–∞") or not row.get("–ù–æ–º–µ—Ä –≤–æ–ø—Ä–æ—Å–∞"):
                            continue
                        branch = int(row["–í–µ—Ç–∫–∞"])
                        q_id = int(row["–ù–æ–º–µ—Ä –≤–æ–ø—Ä–æ—Å–∞"])
                        if q_id not in questions[branch]:
                            image_path = os.path.join(self.images_dir, f"image{q_id}.jpg")
                            questions[branch][q_id] = {
                                "text": row.get("–í–≤–æ–¥–Ω–∞—è", ""),
                                "options": {},
                                "is_final": row.get("–§–∏–Ω–∞–ª", "").strip().lower() in ("–¥–∞", "yes", "1"),
                                "image_path": image_path if os.path.exists(image_path) else None
                            }
                        if row.get("–í—ã–±–æ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è") and row.get("–í–∞—Ä–∏–∞–Ω—Ç –≤–æ–ø—Ä–æ—Å–∞"):
                            choice = int(row["–í—ã–±–æ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"])
                            questions[branch][q_id]["options"][choice] = {
                                "text": row["–í–∞—Ä–∏–∞–Ω—Ç –≤–æ–ø—Ä–æ—Å–∞"],
                                "next_q": int(row["–°–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å"]) if row.get("–°–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å") else None,
                                "confirmation": row.get("–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –≤—ã–±–æ—Ä–∞", "").strip(),
                                "emoji": row.get("–≠–º–æ–¥–∑–∏", "üîπ"),
                                "portrait": row.get("–ü–æ—Ä—Ç—Ä–µ—Ç", "—É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π —Ä–∞–±–æ—Ç–Ω–∏–∫"),
                                "advice": row.get("–°–æ–≤–µ—Ç", ""),
                                "description": row.get("–û–ø–∏—Å–∞–Ω–∏–µ –ø–æ—Ä—Ç—Ä–µ—Ç–∞", "")
                            }
                    except (ValueError, KeyError) as e:
                        logger.error("–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å—Ç—Ä–æ–∫–∏ CSV: %s. –û—à–∏–±–∫–∞: %s",
                                     mask_sensitive_data(str(row)), mask_sensitive_data(str(e)))
                        continue
        except Exception as e:
            logger.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ CSV: %s", mask_sensitive_data(str(e)))
        return questions

    async def ask_for_subscription(self, user_id: int, query: CallbackQuery):
        session = self.user_sessions.get(user_id)
        if not session:
            return

        if session.seen_subscription_prompt:
            await self.show_final_message(user_id, query)
            return

        session.seen_subscription_prompt = True

        text = (
            "üéâ <b>–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º, –≤—ã —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–∏–ª–∏ —Ç–µ—Å—Ç!</b>\n\n"
            "–ü–µ—Ä–µ–¥ —Ç–µ–º, –∫–∞–∫ –ø–æ–ª—É—á–∏—Ç—å —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç, –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∫–∞–Ω–∞–ª <b>–ö–æ–ª–ª–µ–∫—Ç–∏—É–º</b>.\n\n"
            "–ü–ª–æ—â–∞–¥–∫–∞ –¥–ª—è —É–º–Ω—ã—Ö –∏ –ª—é–±–æ–∑–Ω–∞—Ç–µ–ª—å–Ω—ã—Ö –ª—é–¥–µ–π, —Å –∞–≤—Ç–æ—Ä—Å–∫–æ–π –∞–Ω–∞–ª–∏—Ç–∏–∫–æ–π –≤—Å–µ—Ö –∑–Ω–∞—á–∏–º—ã—Ö —Å–æ–±—ã—Ç–∏–π –≤ –º–∏—Ä–µ. "
            "–ù–æ–≤–æ—Å—Ç–∏ –ø–æ–ª–∏—Ç–∏–∫–∏, —ç–∫–æ–Ω–æ–º–∏–∫–∏ –∏ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–π. –ì–ª–∞–≤–Ω—ã–µ —Ç—Ä–µ–Ω–¥—ã –∏ –∫–ª—é—á–µ–≤—ã–µ –∏–≥—Ä–æ–∫–∏ ‚Äî –≤—Å—ë, —á—Ç–æ –Ω—É–∂–Ω–æ –∑–Ω–∞—Ç—å "
            "–æ —Ç–∞–π–Ω—ã—Ö –º–µ—Ö–∞–Ω–∏–∑–º–∞—Ö –Ω–∞—à–µ–π —Ü–∏–≤–∏–ª–∏–∑–∞—Ü–∏–∏."
        )

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚úÖ –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è", url="https://t.me/day_capitalist")],
            [InlineKeyboardButton("‚û°Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_subscription")]
        ])

        try:
            await query.edit_message_text(
                text=text,
                reply_markup=keyboard,
                parse_mode="HTML"
            )
        except Exception as e:
            if "message is not modified" in str(e) or "not enough rights" in str(e):
                pass
            else:
                try:
                    await query.message.delete()
                except Exception:
                    pass
                try:
                    await query.message.reply_text(
                        text=text,
                        reply_markup=keyboard,
                        parse_mode="HTML"
                    )
                except Exception as e2:
                    logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É: %s", mask_sensitive_data(str(e2)))
                    await self.show_final_message(user_id, query)

    async def skip_subscription(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.answer()
        user_id = update.effective_user.id
        try:
            await query.message.delete()
        except Exception:
            pass
        await self.show_final_message(user_id, query)

    async def show_final_message(self, user_id: int, query: CallbackQuery):
        session = self.user_sessions.get(user_id)
        if not session:
            return

        portrait_key = session.portrait.lower()
        portrait_description = ""
        for branch in self.questions.values():
            for question in branch.values():
                for option in question.get("options", {}).values():
                    if option.get("portrait", "").lower() == portrait_key:
                        desc = option.get("description", "").strip()
                        if desc:
                            portrait_description = desc
                            break
                if portrait_description:
                    break
            if portrait_description:
                break

        if not portrait_description:
            portrait_description = (
                f"<b>–¢–≤–æ–π –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π –ø–æ—Ä—Ç—Ä–µ—Ç: {session.portrait}</b>\n"
                "–¢—ã –æ–±–ª–∞–¥–∞–µ—à—å –¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–º —Å–æ—á–µ—Ç–∞–Ω–∏–µ–º —Ä–∞–∑—É–º–Ω—ã—Ö –∫–∞—á–µ—Å—Ç–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–º–æ–≥—É—Ç —Ç–µ–±–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ –¥–æ–±–∏—Ç—å—Å—è —É—Å–ø–µ—Ö–∞ –≤ –∫–∞—Ä—å–µ—Ä–µ."
            )

        unique_advices = list(dict.fromkeys(session.advices))
        number_emojis = ["1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£", "7Ô∏è‚É£", "8Ô∏è‚É£", "9Ô∏è‚É£", "üîü"]
        advice_lines = []
        for i, advice in enumerate(unique_advices):
            formatted_advice = advice.replace('*', '')
            dot_pos = formatted_advice.find('.')
            newline_pos = formatted_advice.find('\n')
            split_pos = -1
            if dot_pos > 0 and newline_pos > 0:
                split_pos = min(dot_pos, newline_pos)
            elif dot_pos > 0:
                split_pos = dot_pos
            elif newline_pos > 0:
                split_pos = newline_pos
            if split_pos > 0:
                portrait_name = formatted_advice[:split_pos].strip()
                advice_text = formatted_advice[split_pos+1:].strip()
                if formatted_advice[split_pos] == '.':
                    portrait_name += '.'
                advice_lines.append(f"{number_emojis[i] if i < len(number_emojis) else f'{i+1}.'} <b>{portrait_name}</b>\n{advice_text}")
            else:
                advice_lines.append(f"{number_emojis[i] if i < len(number_emojis) else f'{i+1}.'} {formatted_advice}")

        channel_updates = await self.get_channel_updates()

        salary_template_link = "https://docs.google.com/document/d/1hOaWvUnRAfpb0Gf4yo6Xp49lFmCQ2oCsaxKMyVSyVt8/edit?tab=t.0"

        final_text = (
            f"{portrait_description}\n"
            f"üéØ <b>–¢–≤–æ–∏ –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:</b>\n"
            + "\n".join(advice_lines) + "\n"
            f"\n""üìå <b>–ë–æ–Ω—É—Å:</b> –£–≤–µ—Ä–µ–Ω –≤ —Å–≤–æ–µ–π —Ü–µ–Ω–Ω–æ—Å—Ç–∏? –ò—Å–ø–æ–ª—å–∑—É–π —à–∞–±–ª–æ–Ω –ø–∏—Å—å–º–µ–Ω–Ω–æ–≥–æ –∑–∞—è–≤–ª–µ–Ω–∏—è –Ω–∞ –ø–æ–≤—ã—à–µ–Ω–∏–µ –∑–∞—Ä–ø–ª–∞—Ç—ã:\n"
            f"<a href='{salary_template_link}'>üìÑ –û—Ç–∫—Ä—ã—Ç—å –≤ GoogleDoc </a>\n\n"
            "<b>–ù–µ –∑–∞–º—ã–∫–∞–π—Å—è —Ç–æ–ª—å–∫–æ –≤ —Ä–∞–±–æ—Ç–µ. –ï—Å–ª–∏ —Ö–æ—á–µ—à—å –ø–æ–≤—ã—Å–∏—Ç—å —Å–≤–æ–π —É—Ä–æ–≤–µ–Ω—å –ø–æ –∂–∏–∑–Ω–∏, —Å–ª–µ–¥–∏ –∑–∞ –≤—Å–µ–º–∏ —Ç—Ä–µ–Ω–¥–∞–º–∏.</b>\n\n"
            f"–ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ <b>–ö–æ–ª–ª–µ–∫—Ç–∏—É–º</b> ‚Äî –∞–≤—Ç–æ—Ä—Å–∫–∏–π –∫–∞–Ω–∞–ª –æ —Ñ–∏–Ω–∞–Ω—Å–∞—Ö, —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—è—Ö, "
            f"—ç–∫–æ–Ω–æ–º–∏–∫–µ –∏ –≥–µ–æ–ø–æ–ª–∏—Ç–∏–∫–µ. –£–∑–Ω–∞–π, –∫–∞–∫ —É—Å—Ç—Ä–æ–µ–Ω –Ω–∞—à –º–∏—Ä –∏ –∫—É–¥–∞ –æ–Ω –¥–≤–∏–∂–µ—Ç—Å—è!\n\n"
            f"<b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã:</b>\n"
            f"{channel_updates}\n"
            f"\n""–ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Å—è: <a href='https://t.me/day_capitalist'>–ö–∞–Ω–∞–ª</a> | <a href='https://t.me/day_capitalist_club'>–°–æ–æ–±—â–µ—Å—Ç–≤–æ</a>"
        )

        try:
            try:
                await query.edit_message_text(
                    text=final_text,
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üîÑ –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ", callback_data="restart")]]),
                    parse_mode="HTML",
                    disable_web_page_preview=True
                )
            except Exception:
                await query.message.reply_text(
                    text=final_text,
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üîÑ –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ", callback_data="restart")]]),
                    parse_mode="HTML",
                    disable_web_page_preview=True
                )
                try:
                    await query.message.delete()
                except Exception:
                    pass
        except Exception as e:
            logger.error("–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∫–∞–∑–µ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è: %s", mask_sensitive_data(str(e)))
            await query.message.reply_text(
                "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üîÑ –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ", callback_data="restart")]])
            )
        finally:
            self.user_sessions.pop(user_id, None)

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        self.user_sessions[user_id] = UserSession()
        message = update.message if update.message else update.callback_query.message
        start_image_path = os.path.join(self.images_dir, "image0.jpg")
        caption = (
            "üëã <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∫–∞—Ä—å–µ—Ä–Ω–æ–≥–æ —Å–æ–≤–µ—Ç–Ω–∏–∫–∞!</b>\n"
            "–≠—Ç–æ—Ç –±–æ—Ç –ø–æ–º–æ–∂–µ—Ç —Ç–µ–±–µ:\n"
            "- –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å\n"
            "- –î–∞—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏\n"
            "–ì–æ—Ç–æ–≤ –Ω–∞—á–∞—Ç—å? –ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ!"
        )
        try:
            if os.path.exists(start_image_path):
                with open(start_image_path, 'rb') as photo:
                    await message.reply_photo(
                        photo=photo,
                        caption=caption,
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton("üöÄ –ù–∞—á–∞—Ç—å –æ–ø—Ä–æ—Å", callback_data="branch_1")]
                        ]),
                        parse_mode="HTML"
                    )
            else:
                await message.reply_text(
                    caption,
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("üöÄ –ù–∞—á–∞—Ç—å –æ–ø—Ä–æ—Å", callback_data="branch_1")]
                    ]),
                    parse_mode="HTML"
                )
        except Exception as e:
            logger.error("–û—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ start: %s", mask_sensitive_data(str(e)))
            await message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")

    async def handle_branch(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.answer()
        user_id = update.effective_user.id
        try:
            branch = int(query.data.split("_")[1])
            self.user_sessions[user_id] = UserSession()
            session = self.user_sessions[user_id]
            session.start_branch(branch)
            if branch == 1:
                session.current_q = 2
                session.history = [1, 2]
            question = session.get_current_question(self.questions)
            if not question:
                await self.clean_session(user_id, update, "–û—à–∏–±–∫–∞: –≤–æ–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω")
                return
            text = question['text']
            if session.confirmations:
                text = "‚úÖ " + "\n".join(session.confirmations) + "\n" + text
                session.confirmations.clear()
            keyboard = [
                [InlineKeyboardButton(f"{opt.get('emoji', 'üîπ')} {opt['text']}", callback_data=f"answer_{cid}")]
                for cid, opt in question["options"].items()
            ]
            if len(session.history) > 1:
                keyboard.append([InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="back")])
            try:
                if question.get("image_path"):
                    try:
                        with open(question["image_path"], 'rb') as photo:
                            await query.message.reply_photo(
                                photo=photo,
                                caption=text,
                                reply_markup=InlineKeyboardMarkup(keyboard),
                                parse_mode="Markdown"
                            )
                    except FileNotFoundError:
                        logger.warning(f"Image not found: {question['image_path']}")
                        await query.edit_message_text(
                            text=text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode="Markdown"
                        )
                else:
                    await query.edit_message_text(
                        text=text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode="Markdown"
                    )
            except Exception as e:
                logger.error("–û—à–∏–±–∫–∞ –ø–æ–∫–∞–∑–∞ –≤–æ–ø—Ä–æ—Å–∞: %s", mask_sensitive_data(str(e)))
                await self.clean_session(user_id, update, "–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –≤–æ–ø—Ä–æ—Å–∞.")
        except Exception as e:
            logger.error("–û—à–∏–±–∫–∞ –≤ handle_branch: %s", mask_sensitive_data(str(e)))
            await self.clean_session(user_id, update, "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –î–∞–≤–∞–π—Ç–µ –Ω–∞—á–Ω—ë–º –∑–∞–Ω–æ–≤–æ.")

    async def show_question(self, update: Update, user_id: int):
        session = self.user_sessions.get(user_id)
        if not session:
            await self.clean_session(user_id, update)
            return
        question = session.get_current_question(self.questions)
        if not question:
            await self.clean_session(user_id, update, "–û—à–∏–±–∫–∞: –≤–æ–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return
        text = question['text']
        if session.confirmations:
            text = "‚úÖ " + "\n".join(session.confirmations) + "\n" + text
            session.confirmations.clear()
        keyboard = [
            [InlineKeyboardButton(f"{opt.get('emoji', 'üîπ')} {opt['text']}", callback_data=f"answer_{cid}")]
            for cid, opt in question["options"].items()
        ]
        if len(session.history) > 1:
            keyboard.append([InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="back")])
        try:
            if question.get("image_path"):
                try:
                    with open(question["image_path"], 'rb') as photo:
                        if update.callback_query:
                            await update.callback_query.message.reply_photo(
                                photo=photo,
                                caption=text,
                                reply_markup=InlineKeyboardMarkup(keyboard),
                                parse_mode="Markdown"
                            )
                        else:
                            await update.message.reply_photo(
                                photo=photo,
                                caption=text,
                                reply_markup=InlineKeyboardMarkup(keyboard),
                                parse_mode="Markdown"
                            )
                except FileNotFoundError:
                    logger.warning(f"Image not found: {question['image_path']}")
                    if update.callback_query:
                        await update.callback_query.edit_message_text(
                            text=text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode="Markdown"
                        )
                    else:
                        await update.message.reply_text(
                            text=text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode="Markdown"
                        )
            else:
                if update.callback_query:
                    await update.callback_query.edit_message_text(
                        text=text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode="Markdown"
                    )
                else:
                    await update.message.reply_text(
                        text=text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode="Markdown"
                    )
        except Exception as e:
            logger.error("–û—à–∏–±–∫–∞ –ø–æ–∫–∞–∑–∞ –≤–æ–ø—Ä–æ—Å–∞: %s", mask_sensitive_data(str(e)))
            await self.clean_session(user_id, update, "–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –≤–æ–ø—Ä–æ—Å–∞.")

    async def handle_answer(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query: CallbackQuery = update.callback_query
        await query.answer()
        user_id = update.effective_user.id
        session = self.user_sessions.get(user_id)
        if not session:
            await self.clean_session(user_id, update)
            return
        try:
            choice_id = int(query.data.split("_")[1])
            question = session.get_current_question(self.questions)
            if not question:
                await self.clean_session(user_id, update, "–û—à–∏–±–∫–∞: –≤–æ–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω")
                return
            option = question["options"].get(choice_id)
            if not option:
                await query.message.reply_text("–ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä")
                return
            if option.get("confirmation"):
                session.add_confirmation(option["confirmation"])
            if option.get("portrait"):
                session.add_portrait(option["portrait"])
            if option.get("advice"):
                session.add_advice(option["advice"])
            next_q = option.get("next_q")
            if next_q is None or question.get("is_final", False) or (session.branch == 1 and session.current_q == 12):
                await self.ask_for_subscription(user_id, query)
                return
            session.move_to_next(next_q)
            await self.show_question(update, user_id)
        except Exception as e:
            logger.error("–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—Ç–≤–µ—Ç–∞: %s", mask_sensitive_data(str(e)))
            await self.clean_session(user_id, update, "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ—Ç–≤–µ—Ç–∞.")

    async def handle_back(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.answer()
        user_id = update.effective_user.id
        session = self.user_sessions.get(user_id)
        if not session or not session.go_back():
            await query.message.reply_text("–ù–µ–ª—å–∑—è –≤–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞–∑–∞–¥")
            return
        await self.show_question(update, user_id)

    async def handle_restart(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.answer()
        user_id = update.effective_user.id
        self.user_sessions[user_id] = UserSession()
        await self.start(update, context)

    async def clean_session(self, user_id: int, update: Update, msg: str = "–°–µ—Å—Å–∏—è —Å–±—Ä–æ—à–µ–Ω–∞"):
        self.user_sessions.pop(user_id, None)
        try:
            if update.callback_query:
                await update.callback_query.message.reply_text(msg)
            else:
                await update.message.reply_text(msg)
        except Exception as e:
            logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ —Å–µ—Å—Å–∏–∏: %s", mask_sensitive_data(str(e)))

    def run(self):
        token = os.getenv("BOT_TOKEN")
        if not token:
            logger.error("BOT_TOKEN –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ .env —Ñ–∞–π–ª–µ")
            return
        try:
            app = Application.builder().token(token).build()
            app.add_handler(CommandHandler("start", self.start))
            app.add_handler(CallbackQueryHandler(self.handle_branch, pattern=r"^branch_"))
            app.add_handler(CallbackQueryHandler(self.handle_restart, pattern=r"^restart$"))
            app.add_handler(CallbackQueryHandler(self.handle_back, pattern=r"^back$"))
            app.add_handler(CallbackQueryHandler(self.handle_answer, pattern=r"^answer_"))
            app.add_handler(CallbackQueryHandler(self.skip_subscription, pattern=r"^skip_subscription$"))
            app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND,
                                         lambda u, c: u.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏")))
            logger.info("–§–∏–Ω–∞–Ω—Å–æ–≤—ã–π –±–æ—Ç –∑–∞–ø—É—â–µ–Ω")
            app.run_polling()
        except KeyboardInterrupt:
            logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤—Ä—É—á–Ω—É—é")
        except Exception as e:
            logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞: %s", mask_sensitive_data(str(e)))


if __name__ == "__main__":
    try:
        bot = FinanceBot()
        bot.run()
    except Exception as e:
        logger.error("–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: %s", mask_sensitive_data(str(e)))
        input("–ù–∞–∂–º–∏—Ç–µ Enter –¥–ª—è –≤—ã—Ö–æ–¥–∞...")